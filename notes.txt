Lect: 2
npm i -D parcel => parcel is getting installed as Dev dependency
parcel has dependencies => its dependencies has their own dependencies => transitive dependencies
dependency vs dev dependency : "dependencies" : Packages required by your application in production. "devDependencies" : Packages that are only needed for local development and testing.

Lect: 3
npm run start === npm start
npm run build !== npm build
only start keyword is reserved like that
using React.createElement is not friendly, so JSX was introduced
JSX is not html inside jsvascript
JSX is totally different, it has HTML-like or XML-like syntax
It is totally different syntax
React.createElement() => React Element which is an Object => on rendering => HTML Element (babal does all these things)
JSX is transpiled before it reaches the JS engine -> done by Parcel using Babel
JSX => converted to react.createElement by Babel=> React Element which is an Object => on rendering => HTML Element
try to explore different attributes for JSX as compared to html
putting one component inside other is called component composition
React component is a JS function which returns some JSX code.
Instead of arrow function, we can also write normal fucntions, but we shall be using arrow.
we can inject any JS code inside JSx using {}
All three are same: 
    <Title />
    <Title></Title>
    {Title()}
We can put react-element inside react-component, react-component inside another react-component, reacct-compoenent inside react-element using {}
JSX sanitizes the JS which we are trying to inject using {}, and hence prevents from Cross-Side Scripting Attack
At the end of the day: 
    React is JS
    Functional Components are JS fucntions
    JSX is react.createElement 
    react.createElement is Object 

Lect: 04
Always plan about how the ui should look like, then start coding
For inline CSS: 
     style={{backgroundColor: "#f0f0f0"}}
     first {} => some js is coming
     second {} => the js object containing the css 

To dynamically pass data to a component, we use props 
It is same as passing arguments to a function as react components are JS functions only.
React wraps everything in an object and passes them
Config-driven UI: Website is driven by config received from backend
not using keys (not acceptable) <<< index as keys <<<<<<<<<< unique id (best practice)

Lect: 05
Never keep hard-coded data in components folder
Two types of exprt and import : Named-export and default export
1. Named:   export const Variable;
            import {Variable} from "path"
    When we need to export multiple things

2. Default: export default Variable
            import Variable from "path"

Can I do mix-export and imports ? 

Using React, we want to sync the data and UI.
React Hooks: Normal JS utility functions, written by facebook developers
- useStae() : Super powerful state variables
            : Whenever a state variable updates, React re-renders the component (or react triggers a reconciliation cycle)
            : rendering => calling that component function again
            : On re-rendering entire function is again executed
            : All three are same: 
                const [listOfRestaurants, setListOfRestaurants] = useState(resList)
                const arr = useState(resList)
                const [listOfRestaurants, setListOfRestaurants] = arr;
                const listOfRestaurants = arr[0];
                const setListOfRestaurants = arr[1];
- useEffect() : Runs when the compoenent has been rendered

React uses React-Fiber(Reconciliatio) algorithm to easily maintain a virtual DOM(an object representation of actual DOM), finds the diff and then changes the actual DOM very efficiently.

Lect: 06
useEffect is called when that component has been rendered
If we pass [] => useEffect is only called for the first render of that compoenent
added cors plugin to handle cors issue => watch CORS video on youtube
For better UI experence, we should use shimmer ui effect

If isLoggedIn is declared with const, how can we still update its value?
We're not changing the const variable, we're changing the value it points to via the setIsLoggedIn function.
Implement lazy loading as user scrolls down

Lect: 07
useEffect Impt points: 
    1. If no dependency array => useEffectis called on every render
    2. If dependency array is empty ([]) => useEffectis called only on initial render
    3. If dependency array is like [variable] => called every time the variable updates
useState  impt points: 
    1. Used to create local state varables inside a component
    2. Always initialize useState at the top of component
    3. Never use useState inside if-else, for-loop, functions


We should not use anchor tag for redirecting in react as it reloads the entire page
We should use Link, provided by react-router-dom
If we use Link then, only that component is loaded.
And that's why react is called as Single Page Apllication using client side routing

Routing configuration (what will happen for a specific path) for the root-level app.
create Configuration: const appRouter = createBrowserRouter([{}, {} ,{}])
provide configuration   : RouterProvider is a compoenent which we'll render instead of the root -evel component (mostly app.js)
                        : root.render(<RouterProvider router={appRouter} />)
To handle error, react-router-dom provides us a hook called "useRouteError"
On every other route: I want my header ot be there => we use children routes, with Outlet
Outlet gets filled with the children according to the path
Q. Can I add multiple and nested Outlets?
We can navigate to new route without reloading the entire page: "Link"
Link is a compoenent given by react-router-dom, which internally uses anchor(a) tag
In the html, we will notice "a" tag, instead of Link.


In web-applications, we have two types of routing: 

1. Client side rotuting => all the compoenets are already loaded and no network call is made, n/w call is only amade when we fetch using api.

2. Server side routing => make a netword call and that html page is coming from Server

Dynamic routing : 

path: "/restaurants/:resId": It means that, resId will be different and dynamic for different routes
how to get this id in the compoenent? =. using hook "useParams"


Note: 
    setResInfo(jsonData.data);
    // here its throwing undefined even after setting the value?
    console.log("a", resInfo);
    setResInfo(...) doesn't immediately change resInfo.
    console.log(resInfo) right after it will still show the previous value.
    Use useEffect to observe state updates:
    useEffect(() => {
        console.log("resInfo updated:", resInfo);
        }, [resInfo]);

Lect: 08

Class Based Component: We need to extend React.Component class with our new class name, 
use render method and return the same JSX which you could have returned in the functional component.
Export the class, use the same way we are using normal functional component

To pass variables in fxn based: we pass like var={} and receive inside the function as props object
To pass variables in class based: We pass the same way, for receiving we use constructor, which does super(props), and we use variables like this.props.varName or destructure

By calling super(props), you ensure that the parent class (React.Component) 
performs its necessary initializations, 
allowing your component to function correctly within the React framework. 
This is crucial for accessing this.props and setting up the componentâ€™s 
initial state based on the props.

Handling state variables: 

In fxnl based components, we use useState hook to handle them, but at the end: React maintains a single big objct to maintain all the state variables

In class based: We use constructor for creating and managing state variables.

this.state = {
    one big object, which has all the state variables.
}
NEVER UPDATE STATE VARIABLES DIRECTLY: this.state.count = this.state.count + 1;
We use: this.setState({values to be updtaed}), and react will update the values provided to the set state, and won't touch the other state variables. And when the value changes, the component is re-rendered.